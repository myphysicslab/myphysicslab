// Copyright 2016 Erik Neumann.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { GenericVector, Vector } from "./Vector.js";
import { Util } from "./Util.js";

/** Specifies an immutable 2D affine transform.

The affine transform of a point `(x, y)` is given by:

    [  m11  m21  dx  ] [ x ]   [ m11 x + m21 y + dx ]
    [  m12  m22  dy  ] [ y ] = [ m12 x + m22 y + dy ]
    [   0    0    1  ] [ 1 ]   [          1         ]

Rotation clockwise by theta radians:

    [ cos(theta)  -sin(theta)   0 ]
    [ sin(theta)   cos(theta)   0 ]
    [     0            0        1 ]

Scale:

    [  sx   0    0  ]
    [  0   sy    0  ]
    [  0    0    1  ]

Translate:

    [  1    0   dx  ]
    [  0    1   dy  ]
    [  0    0    1  ]

Below are examples of specifying an AffineTransform with
{@link lab/view/DisplayShape.DisplayShape.setImageAT}. The example images were
generated by altering the application
{@link sims/engine2D/DoublePendulum2App.DoublePendulum2App}.

<img src="../DisplayPolygon_Image.png">
*/
export class AffineTransform {
  private readonly m11_: number;
  private readonly m12_: number;
  private readonly m21_: number;
  private readonly m22_: number;
  private readonly dx_: number;
  private readonly dy_: number;

constructor(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number) {
  this.m11_ = m11;
  this.m12_ = m12;
  this.m21_ = m21;
  this.m22_ = m22;
  this.dx_ = dx;
  this.dy_ = dy;
};

/** @inheritDoc */
toString() {
  return 'AffineTransform{m11_: '+Util.NF(this.m11_)
      +', m12_: '+Util.NF(this.m12_)
      +', m21_: '+Util.NF(this.m21_)
      +', m22_: '+Util.NF(this.m22_)
      +', dx_: '+Util.NF(this.dx_)
      +', dy_: '+Util.NF(this.dy_)
      +'}';
};

/** Multiplies the affine transform of the given context with this AffineTransform.
* @param context the canvas context to modify
*/
applyTransform(context: CanvasRenderingContext2D) {
  context.transform(this.m11_, this.m12_, this.m21_, this.m22_, this.dx_, this.dy_);
};

/** Right-multiply this AffineTransform by the given AffineTransform. This has the
effect that the given AffineTransform will be applied to the input vector before the
current AffineTransform.

Concatenating a transform A to transform B is equivalent to matrix multiplication of
the two transforms. Note that order matters: matrices are applied in right to left order
when transforming a vector
```text
A B vector = A * (B * vector)
```
We can think of the B matrix being applied first, then the A matrix.  This method
returns the product with the input `at` matrix on the right
```text
this * at
```
The mathematics is as follows: this matrix is on the left, the other `at` matrix is on
the right:
```text
[  m11  m21  dx  ]  [  a11  a21  ax  ]
[  m12  m22  dy  ]  [  a12  a22  ay  ]
[   0    0    1  ]  [   0    0   1   ]
```
Result is:
```text
[ (m11*a11 + m21*a12)  (m11*a21 + m21*a22)  (m11*ax + m21*ay + dx) ]
[ (m12*a11 + m22*a12)  (m12*a21 + m22*a22)  (m12*ax + m22*ay + dy) ]
[          0                    0                   1              ]
```
@param at the AffineTransform matrix to
  right-multiply this AffineTransform matrix by
@return the product of this AffineTransform
  matrix right-multiplied by the `at` AffineTransform matrix
*/
concatenate(at: AffineTransform): AffineTransform {
  const m11 = this.m11_ * at.m11_ + this.m21_ * at.m12_;
  const m12 = this.m12_ * at.m11_ + this.m22_ * at.m12_;
  const m21 = this.m11_ * at.m21_ + this.m21_ * at.m22_;
  const m22 = this.m12_ * at.m21_ + this.m22_ * at.m22_;
  const dx =  this.m11_ * at.dx_  + this.m21_ * at.dy_ + this.dx_;
  const dy =  this.m12_ * at.dx_  + this.m22_ * at.dy_ + this.dy_;
  return new AffineTransform(m11, m12, m21, m22, dx, dy);
};

/** Draw a line to the transformed point.
* @param x horizontal coordinate
* @param y vertical coordinate
* @param context the canvas context to modify
*/
lineTo(x: number, y: number, context: CanvasRenderingContext2D) {
  const p = this.transform(x, y);
  context.lineTo(p.getX(), p.getY());
};

/** Sets current position in context to the transformed point.
* @param x horizontal coordinate
* @param y vertical coordinate
* @param context the canvas context to modify
*/
moveTo(x: number, y: number, context: CanvasRenderingContext2D) {
  const p = this.transform(x, y);
  context.moveTo(p.getX(), p.getY());
};

/** Concatenates a rotation transformation to this AffineTransform.

The mathematics is as follows: this matrix is on the left, the rotation matrix is on
the right, and the angle is represented by `t`
```text
[  m11  m21  dx  ]  [ cos(t)  -sin(t)   0 ]
[  m12  m22  dy  ]  [ sin(t)   cos(t)   0 ]
[   0    0    1  ]  [  0        0       1 ]
```
Result is:
```text
[  (m11*cos(t) + m21*sin(t))  (-m11*sin(t) + m21*cos(t))  0  ]
[  (m12*cos(t) + m22*sin(t))  (-m12*sin(t) + m22*cos(t))  0  ]
[              0                          0               1  ]
```
@param angle angle in radians to; positive angle rotates clockwise.
@return a new AffineTransform equal to
    this AffineTransform rotated by the given angle
*/
rotate(angle: number): AffineTransform {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  const m11 = c*this.m11_ + s*this.m21_;
  const m12 = c*this.m12_ + s*this.m22_;
  const m21 = -s*this.m11_ + c*this.m21_;
  const m22 = -s*this.m12_ + c*this.m22_;
  return new AffineTransform(m11, m12, m21, m22, this.dx_, this.dy_);
};

/**  Concatenates a scaling transformation to this AffineTransform.

The mathematics is as follows: this matrix is on the left, the scaling matrix is on
the right:
```text
[  m11  m21  dx  ]  [  x   0   0  ]
[  m12  m22  dy  ]  [  0   y   0  ]
[   0    0    1  ]  [  0   0   1  ]
```
Result is:
```text
[  m11*x  m21*y  dx  ]
[  m12*x  m22*y  dy  ]
[   0      0      1  ]
```
@param x factor to scale by in horizontal direction
@param y factor to scale by in vertical direction
@return a new AffineTransform equal to
    this AffineTransform scaled by the given x and y factors
*/
scale(x: number, y: number): AffineTransform {
  const m11 = this.m11_ * x;
  const m12 = this.m12_ * x;
  const m21 = this.m21_ * y;
  const m22 = this.m22_ * y;
  return new AffineTransform(m11, m12, m21, m22, this.dx_, this.dy_);
};

/**  Set the affine transform of the given context to match this AffineTransform.
* @param context the canvas context to modify
*/
setTransform(context: CanvasRenderingContext2D) {
  context.setTransform(this.m11_, this.m12_, this.m21_, this.m22_, this.dx_, this.dy_);
};

/**  Apply this transform to the given point, returning the transformation
of the given point.

The mathematics is as follows:
```text
[  m11  m21  dx  ]  [ x ]
[  m12  m22  dy  ]  [ y ]
[   0    0    1  ]  [ 1 ]
```
Result is:
```text
[ m11 x + m21 y + dx ]
[ m12 x + m22 y + dy ]
[          1         ]
```
@param x the x coordinate or Vector containing both x and y
@param y the y coordinate (or undefined if a vector was passed for x)
@return the transformation of the given point.
@throws if x is not a GenericVector, or x, y are not numbers
*/
transform(x: GenericVector|number, y?: number): Vector {
  let x1, y1;
  if (typeof x === 'number') {
    x1 = x;
    y1 = y;
  } else {
    const v = x;
    y1 = v.getY();
    x1 = v.getX();
  }
  if (typeof x1 !== 'number' || typeof y1 !== 'number') {
    throw 'need a Vector or two numbers';
  }
  const x2 = this.m11_ * x1 + this.m21_ * y1 + this.dx_;
  const y2 = this.m12_ * x1 + this.m22_ * y1 + this.dy_;
  return new Vector(x2, y2);
};

/** Concatenates a translation to this AffineTransform.

The mathematics is as follows: this matrix is on the left, the scaling matrix is on
the right:
```text
[  m11  m21  dx  ]  [  1    0   x  ]
[  m12  m22  dy  ]  [  0    1   y  ]
[   0    0    1  ]  [  0    0   1  ]
```
Result is:
```text
[ m11  m21  (m11*x + m21*y + dx) ]
[ m12  m22  (m12*x + m22*y + dy) ]
[ 0    0            1            ]
```
@param x the x coordinate or vector
@param y the y coordinate (or undefined if a vector was passed for x)
@return a new AffineTransform equal to
    this AffineTransform  translated by the given amount
@throws if x is not a GenericVector, or x, y are not numbers
*/
translate(x: GenericVector|number, y?: number): AffineTransform {
  let x1, y1;
  if (typeof x === 'number') {
    x1 = x;
    y1 = y;
  } else {
    const v = x;
    y1 = v.getY();
    x1 = v.getX();
  }
  if (typeof x1 !== 'number' || typeof y1 !== 'number') {
    throw 'need a Vector or two numbers';
  }
  const dx = this.dx_ + this.m11_*x1 + this.m21_*y1;
  const dy = this.dy_ + this.m12_*x1 + this.m22_*y1;
  return new AffineTransform(this.m11_, this.m12_, this.m21_, this.m22_, dx, dy);
};

/** The identity AffineTransform, which leaves a point unchanged when it is applied.
*/
static readonly IDENTITY = new AffineTransform(1, 0, 0, 1, 0, 0);
} // end AffineTransform class

Util.defineGlobal('lab$util$AffineTransform', AffineTransform);
