// Copyright 2016 Erik Neumann.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { AffineTransform } from '../util/AffineTransform.js';
import { Collision } from '../model/Collision.js';
import { DoubleRect } from '../util/DoubleRect.js';
import { LocalCoords } from './LocalCoords.js';
import { MassObject } from '../model/MassObject.js';
import { RigidBody, Edge, Vertex } from './RigidBody.js';
import { SimObject } from '../model/SimObject.js';
import { Util } from '../util/Util.js';
import { Vector, GenericVector } from '../util/Vector.js';

/** The fixed background to which objects can be attached with Springs, Joints or
Ropes; it is an immutable singleton object. Access the singleton Scrim object via
{@link Scrim.getScrim}.

As a RigidBody, Scrim has infinite mass, infinite extent, and never moves. Its
body coordinates are the same as world coordinates.

Scrim does not collide with anything, so it is excluded from the collision and contact
detection phases of the physics engine. It can however appear in a
{@link lab/engine2D/ConnectorCollision.ConnectorCollision} which are generated by
{@link lab/engine2D/Joint.Joint} or {@link lab/engine2D/Rope.Rope}.

Scrim is never on the list of bodies in {@link lab/engine2D/RigidBodySim.RigidBodySim},
only Polygons are on that list.
*/
export class Scrim implements RigidBody, MassObject {

constructor() {};

/** Returns the singleton instance of Scrim.
* @return the singleton instance of Scrim
*/
static getScrim(): Scrim {
  return Scrim.singleton;
};

/** @inheritDoc */
toString() {
  return 'Scrim{}';
};

/** @inheritDoc */
toStringShort() {
  return 'Scrim{}';
};

/** @inheritDoc */
addNonCollide(_bodies: RigidBody[]): void {
};

/** @inheritDoc */
alignTo(_p_body: GenericVector, _p_world: GenericVector, _opt_angle?: number): void {
  throw '';
};

/** @inheritDoc */
bodyToWorld(p_body: GenericVector): Vector {
  return Vector.clone(p_body);
};

/** @inheritDoc */
bodyToWorldTransform(): AffineTransform {
  return AffineTransform.IDENTITY;
};

/** @inheritDoc */
checkCollision(_c: Collision[], _body: RigidBody, _time: number): void {
};

/** @inheritDoc */
createCanvasPath(context: CanvasRenderingContext2D): void{
  // make an empty path
  context.beginPath();
  context.closePath();
};

/** @inheritDoc */
doesNotCollide(_body: RigidBody): boolean{
  return true;
};

/** @inheritDoc */
eraseOldCoords(): void {
};

/** @inheritDoc */
getAccuracy(): number {
  return 0;
};

/** @inheritDoc */
getAngle(): number {
  return 0;
};

/** @inheritDoc */
getAngularVelocity(): number {
  return 0;
};

/** @inheritDoc */
getBottomBody(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getBottomWorld(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getBoundsBody(): DoubleRect {
  return new DoubleRect(this.getLeftBody(), this.getBottomBody(),
      this.getRightBody(), this.getTopBody());
};

/** @inheritDoc */
getBoundsWorld(): DoubleRect {
  return this.getBoundsBody();
};

/** @inheritDoc */
getCenterOfMass(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getCentroidBody(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getCentroidRadius(): number {
  return Infinity;
};

/** @inheritDoc */
getCentroidWorld(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getChanged(): boolean {
  return false;
};

/** @inheritDoc */
getDistanceTol(): number {
  return 0;
};

/** @inheritDoc */
getDragPoints(): Vector[] {
  return [];
};

/** @inheritDoc */
getEdges(): Edge[] {
  return [];
};

/** @inheritDoc */
getElasticity(): number {
  return 1;
};

/** @inheritDoc */
getExpireTime(): number {
  return Infinity;
};

/** @inheritDoc */
getHeight(): number {
  return Infinity;
};

/** @inheritDoc */
getKineticEnergy(): number {
  return 0;
};

/** @inheritDoc */
getLeftBody(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getLeftWorld(): number {
  return Number.NEGATIVE_INFINITY;
};

/** @inheritDoc */
getMass(): number {
  return Infinity;
};

/** @inheritDoc */
getName(_opt_localized?: boolean): string {
  return 'SCRIM';
};

/** @inheritDoc */
getMinHeight(): number {
  return Infinity;
};

/** @inheritDoc */
getOldCoords(): null|LocalCoords {
  return null;
};

/** @inheritDoc */
getPosition(): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getRightBody(): number {
  return Infinity;
};

/** @inheritDoc */
getRightWorld(): number {
  return Infinity;
};

/** @inheritDoc */
getTopBody(): number {
return Infinity;
};

/** @inheritDoc */
getSpecialNormalWorld(): Vector|null {
  return null;
};

/** @inheritDoc */
getTopWorld(): number {
return Infinity;
};

/** @inheritDoc */
getVarName(_index: number, _localized: boolean): string {
  throw '';
};

/** @inheritDoc */
getVarsIndex(): number {
  return -1;
};

/** @inheritDoc */
getVelocity(_p_body?: GenericVector): Vector {
  return Vector.ORIGIN;
};

/** @inheritDoc */
getVelocityTol(): number {
  return 0;
};

/** @inheritDoc */
getVertexes_(): Vertex[] {
  return [];
};

/** @inheritDoc */
getVerticesBody(): Vector[] {
  return [];
};

/** @inheritDoc */
getWidth(): number {
  return Infinity;
};

/** @inheritDoc */
getZeroEnergyLevel(): null|number {
  return null;
};

/** @inheritDoc */
isMassObject(): boolean {
  return true;
};

/** @inheritDoc */
momentAboutCM(): number {
  return Infinity;
};

/** @inheritDoc */
momentum(): number[] {
  const r = new Array(3);
  r[0] = r[1] = r[2] = Infinity;
  return r;
};

/** @inheritDoc */
nameEquals(name: string): boolean {
  return this.getName() == Util.toName(name);
};

/** @inheritDoc */
nonCollideEdge(edge: Edge|null): boolean {
  return edge === null;
};

/** @inheritDoc */
printAll(): void {
};

/** @inheritDoc */
probablyPointInside(_p_body: Vector): boolean {
  return true;
};

/** @inheritDoc */
removeNonCollide(_bodies: RigidBody[]): void {
};

/** @inheritDoc */
rotateBodyToWorld(v_body: GenericVector): Vector {
  return Vector.clone(v_body);
};

/** @inheritDoc */
rotateWorldToBody(v_world: GenericVector): Vector {
  return Vector.clone(v_world);
};

/** @inheritDoc */
rotationalEnergy(): number {
  return 0;
};

/** @inheritDoc */
saveOldCoords(): void {
};

/** @inheritDoc */
setAccuracy(_value: number): void {
};

/** @inheritDoc */
setAngle(_angle: number): void {
};

/** @inheritDoc */
setAngularVelocity(_angular_velocity: number): void {
};

/** @inheritDoc */
setCenterOfMass(_center: GenericVector): void {
};

/** @inheritDoc */
setChanged(): void {
};

/** @inheritDoc */
setDistanceTol(_value: number): void {
};

/** @inheritDoc */
setDragPoints(_dragPts: Vector[]): void {
};

/** @inheritDoc */
setElasticity(_value: number): void {
};

/** @inheritDoc */
setExpireTime(_time: number): void {
};

/** @inheritDoc */
setMass(_mass: number): void {
  throw '';
};

/** @inheritDoc */
setMinHeight(_minHeight: number): void {
};

/** @inheritDoc */
setMomentAboutCM(_moment: number): void {
};

/** @inheritDoc */
setPosition(loc_world: GenericVector, angle?: number): void {
  if (loc_world.getX() != 0 || loc_world.getY() != 0) {
    throw '';
  }
  if (angle !== undefined && angle != 0) {
    throw '';
  }
};

/** @inheritDoc */
setPositionX(_value: number): void {
  throw '';
};

/** @inheritDoc */
setPositionY(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVarsIndex(_index: number): void {
  throw '';
};

/** @inheritDoc */
setVelocity(velocity_world: GenericVector, angular_velocity?: number): void {
  if (velocity_world.getX() != 0 || velocity_world.getY() != 0) {
    throw '';
  }
  if (angular_velocity !== undefined && angular_velocity != 0) {
    throw '';
  }
};

/** @inheritDoc */
setVelocityX(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVelocityY(_value: number): void {
  throw '';
};

/** @inheritDoc */
setVelocityTol(_value: number): void {
};

/** @inheritDoc */
setZeroEnergyLevel(_height?: number): void {
};

/** @inheritDoc */
similar(_obj: SimObject, _opt_tolerance?: number): boolean {
  return false;
};

/** @inheritDoc */
translationalEnergy(): number {
  return 0;
};

/** @inheritDoc */
worldToBody(p_world: GenericVector): Vector {
  return Vector.clone(p_world);
};

static readonly singleton = new Scrim();

} // end Scrim class

Util.defineGlobal('lab$engine2D$Scrim', Scrim);
